const PROMISE = new Promise(function (resolved, rejected){
    resolved("The promise has been fullfilled!");
    rejected("The promise has been rejected!");
});


/* The .then() method takes up to two arguments; the first argument is a callback function for the resolved case of the promise,
and the second argument is a callback function for the rejected case.
Each .then() returns a newly generated promise object, which can optionally be used for chaining */

/* Handling a rejected promise in each .then() has consequences further down the promise chain.
Sometimes there is no choice, because an error must be handled immediately.
In such cases we must throw an error of some type to maintain error state down the chain. */

/* On the other hand, in the absence of an immediate need, it is simpler to leave out error handling until a final .catch() statement.
A .catch() is really just a .then() without a slot for a callback function for the case when the promise is resolved. */

PROMISE
    .then(function(value){      // we are not defining a callback for rejection in the .then() method!
        console.log(value);
        return "A";
    })
    .then(function(value){     // the result of previous block in the chain will be passed as input for the downstream .then() block
        console.log(value);     // i.e value = "A"
        return "B";
    })
    .then(function (value){
        console.log(value);
        return "C";
    })
    .then(function(value){
        console.log(value);
        return "D";     // since there is no downstream .then() method to receive & print the value returned i.e "D"
    })                  // D won't be printed to the console!
    .catch(function(error){     // just a .then() block without a function for handling a resolved promise!
        console.log(error);
        console.log("An error has occurred somewhere!");
    })
// subsequent .then() methods are .then() method for the new promise generated by the previous .then() method!
// this is called chaining!
